<html><body>more序列化工具，more序列化拥有自己独立的序列化格式，该格式是完全由字符串组成因此是在各平台中实现的方便格式。<br /><pre> 
                              软件包使用说明 v1.0 
 
	一、数据类型： 
		N：数字		任意的数字数字可以是java类型可以表示的任意数字其中包括了byte,short,int,long,float,doublt类型。 
		S：字符串 	任意的字符串，字符对象。对于java平台支持Character和CharSequence类型的对象。 
		B：布尔		boolean类型。 
		V：空值		一个空引用的类型 
		A：集合/数组	数组，Collection接口类型 
		T：表		Map对象，任意Object对象。 
		U：自定义类型 其他自定义类型，时间日期就是一个自定义类型。 
	二、原类型名
		N：数字		[More Number]
		S：字符串 	[More String]
		B：布尔		[More Boolean]
		V：空值		[More Void]
		A：集合/数组	[More Array]
		T：表		[More Table]
		U：自定义类型	[More User_xxx]	xxx是继承UserType类实现getUserOriginalName方法的返回值。
		源类型的作用是为了辨别序列化之后的对象类型时使用。
	三、数据类型序列化优先级： 
		NullType &gt; BooleanType &gt; NumberType &gt; StringType &gt; ArrayType &gt; UserType &gt; TableType 
	四、序列化对象要求： 
		注意：more的序列化组建并不能取代相关语言平台上的序列化功能，more的序列化有一个最基本要求就是要序列化的对象必须对某一属性同时 
		具备读写访问权限，并且该属性必须遵循javaBean的get\set属性访问器编写要求。否则将导致序列化反序列化问题。 
	五、序列化 
		String string = MoreSerialization.toString(object); 
		准备序列化的对象使用toString方法将其序列化，序列化时不需要明确指定实现Serializable接口同时序列化时不支持transient关键字。 
	六、反序列化 
		Object object = MoreSerialization.toObject(string); 
		将使用more序列化工具序列化的对象字符串通过toObject进行反序列化。如果在反序列化时无法定位原始对象类型则反序列化将使用Map代替 
		其原始类型。如果属性无法被写入则将忽略其对象。 
	七、序列化格式 
		1.格式 
		&lt;类型&gt;|&lt;内容&gt;[:原始类型]
		类型：前面数据类型中已经定义这里不在多说。
		内容格式：
			类型 格式 										正则
			N：	12.5	-128								^N\|(\+|-)?\d{0,}(\.\d+){0,}$
			S：	""											^S\|\".*\"$
			B：	true	false 								^B\\|(true|false)$
			V：	void										^V|void$
			A：	[]	[]:C	[]:java.util.ArrayList			^A\|\[.*\](:.*)?$
			T：	{key=value}	{key=value}:java.util.Hashtable	^T\|\{.*\}(:.*)?$
			U：	{key=value}:DateTime						^U\|\{.*\}:(.+)$
			注意：对于U类型必须明确指定原始或者被标记的原始类型。
	八、自定义类型序列化
		自定义序列化需要继承UserType类。而且类型需要通过BaseType的静态方法regeditType进行注册才能生效。注意注册顺序。
		getUserOriginalName();	自定义类型的原类型名。
		getType();				自定义类型的原始类型
		testObject();			测试一个对象是否是该类型
		serialization();		序列化实现方法
		deserialize();			反序列化实现方法
</pre></body></html>